\documentclass[10pt,letterpaper,twoside,openright]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}

\author{Carlos Antonio Macías Duarte}
\title{Lista de Algoritmos Heurísticos}
\usepackage[spanish, es-tabla]{babel}
\usepackage[vlined, spanish, onelanguage, ruled, linesnumbered, lined]{algorithm2e}

\begin{document}

	\maketitle
	
	\newpage
			
	\section{Recocido Simulado}
	
		\begin{algorithm}[H]
			\caption{Recocido Simulado (SA)}
			\KwIn{\\$ n $: Tamaño de vecindad\\ $ c $: Control de temperatura\\$ t $: Número de iteraciones}
		 	\KwOut{\\$ g $ : Mejor solución}
				$ i \leftarrow 1 $ : Contador de iteraciones\;
				$ g \leftarrow generarSolucionInicial() $ : Solución inicial\;
				\While {$ i \leq t $}
				{
					$ p \leftarrow \emph{generarVecindad(n,g)}$ : Generar nueva vecindad\;
					$ j \leftarrow 1 $ : Contador de la vecindad\;
					\While {$ j \leq n $}
					{
						\uIf {$p_{j}$ mejor que $g$}
						{
							$ g \leftarrow p_{j} $\;
						}
						\uElseIf{$exp(\dfrac{f(g) - f(p_{j})}{c}) > rand(0,1)$}
						{
							$ g \leftarrow p_{j} $\;
						}
						
					}			
					$ i \leftarrow  i + 1 $\;
					$ n \leftarrow  generarNuevoTamanoVecindad() $ : Genera el nuevo tamaño de la vecindad siguiente\;
					$ c \leftarrow  generarNuevaTemperatura() $\ :  Genera el nuevo valor de control de temperatura;
				}
		 		\Return $ g $
		 \end{algorithm}
		 
		 \newpage
		 
			
	\section{Algoritmo de Selección Clonal}
	
		\begin{algorithm}[H]
			\caption{Algoritmo de Selección Clonal (CLONALG)}
			\KwIn{\\$ N $: Tamaño de población\\ $ n $: Número de celulas a clonar\\$ t $: Número de generaciones}
		 	\KwOut{\\$ g $ : Mejor celula}
				$ i \leftarrow 1 $ : Contador de generaciones\;
				$ p \leftarrow generarPoblacionInicial(N) $ : Población inicial\;
				\While {$ i \leq t $}
				{
					$ q \leftarrow seleccionarMejoresCelulas(p, n) $ : Mejores celulas de la generación\;
					$ c \leftarrow clonar(q)$ : Generar clones\;
					$ m \leftarrow mutar(c)$ : Hipermutación\;
					$ p \leftarrow  generarNuevaPoblacion(p, m, N) $ : Genera la nueva población\;
					$actualizarParametros() $\ :  Actualiza los parametros de clonación y mutación\;
					$ g \leftarrow seleccionarMejorCelula(p) $ : Mejor celula de la generación\;
					$ i \leftarrow  i + 1 $\;
				}
		 		\Return $ g $
		 \end{algorithm}
		 
		 \newpage
	
	\section{Algoritmo Genético}
	
		\begin{algorithm}[H]
			\caption{Algoritmo Génetico (GA)}
			\KwIn{\\$ n $: Tamaño de la población\\ $ t $: Número de generaciones}
		 	\KwOut{\\$ g $ : Mejor individuo}
				$ p \leftarrow inicializarPoblacion(n)$ : Inicialización la primera generación\;
				$ i \leftarrow 1 $ : Contador de iteraciones\;
				$ g \leftarrow seleccionarMejorIndividuo(p) $ : Obtener el mejor individuo\;
				$ u_{c} \leftarrow generarUmbralCruza(0,1) $ : Umbral de cruza\;
				$ u_{m} \leftarrow generarUmbralMutacion(0,1) $ : Umbral de mutación\;
				\While {$ i \leq t $}
				{
					$ q \leftarrow seleccionarParejas(p) $ : Selección de las parejas\;
					$ p \leftarrow cruzar(q,u_{c}) $ : Proceso de cruza de parejas\;
					$ p \leftarrow mutar(p,u_{m}) $ : Proceso de Mutación de individuos\;
					$ p \leftarrow generarNuevaPoblacion(p) $ : Proceso de elitismo\;
					$ g \leftarrow seleccionarMejorIndividuo(p) $\;
					$ i \leftarrow  i + 1 $\;
				}
		 		\Return $ g $
		 \end{algorithm}
		 
		 \newpage
	
	\section{Optimización por Enjambre de Partículas}
	
		\begin{algorithm}[H]
			\caption{Optimización por Enjambre de Partículas (PSO)}
			\KwIn{\\$ n $: Tamaño del enjambre\\ $ t $: Número de iteraciones}
		 	\KwOut{\\$ g $ : Partícula con la mejor posición}
				$ p \leftarrow inicializarEnjambre(n)$ : Inicialización del enjambre\;
				$ i \leftarrow 1 $ : Contador de iteraciones\;
				$ g \leftarrow seleccionarMejorParticula(p) $ : Mejor partícula\;
				\While {$ i \leq t $}
				{
					$ generarNuevaVelocidad(p,g) $ : Actualiza la velocidad de las partículas\;
					$ generarNuevaPosicion(p) $ : Calcular nuevas posiciones\;
					$ g \leftarrow seleccionarMejorParticula(p) $ : Obtener la Mejor partícula\;
					$ i \leftarrow  i + 1 $\;
				}
		 		\Return $ g $
		 \end{algorithm}
		 
		 \newpage
		 
	\section{Búsqueda Armónica}
	
		\begin{algorithm}[H]
			\caption{Búsqueda Armónica (HS)}
			\KwIn{\\$ HMS $: Tamaño de la memoria\\ $ HMCR $: Razón de exploración\\$PAR$: Razón de ajuste de tono\\$BW$: Ancho de desplazamiento\\$NI$: Número de improvisaciones\\$l_{i}$: Límites inferiores\\$l_{s}$: Límites superiores}
		 	\KwOut{\\$ g $ : Mejor armonía}
				$ HM \leftarrow inicializarMemoria(HMS,l_{i},l_{s})$ : Inicialización de la memoria\;
				$ i \leftarrow 1 $ : Contador de iteraciones\;
				\While {$ i \leq NI $}
				{
					$s \leftarrow improvisarArmonia(HM, HMCR,l_{i},l_{s})$ : Creación de nueva armonía\;
					$s \leftarrow ajustarTono(s, PAR, BW,l_{i},l_{s})$ : Ajuste al tono de la armonía\;
					$HM \leftarrow actualizarMemoria(HM,s) $ : Actualización de la memoria\;
					$ i \leftarrow  i + 1 $\;
				}
				$ g \leftarrow seleccionarMejorArmonia(HM) $ : Mejor armonía de la memoria\;
		 		\Return $ g $
		 \end{algorithm}

\end{document}